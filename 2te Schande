#include <Wire.h>
#include <avr/sleep.h>

// -------------------- Pinbelegung --------------------
// HC-SR04
const int TRIG_PIN   = 3;   // D3
const int ECHO_PIN   = 4;   // D4

// Buzzer
const int BUZZER_PIN = 5;   // D5

// Ein/Aus Taster (Interruptfähig)
const int BUTTON_PIN = 2;   // D2

// -------------------- MPU-6050 Anschluss --------------------
// VCC  -> 5V
// GND  -> GND
// SDA  -> A4
// SCL  -> A5
// INT  -> nicht genutzt

const int MPU_ADDR = 0x68;

// -------------------- Systemparameter --------------------
const float SOUND_SPEED = 0.0343;        // cm/µs
const int MAX_DISTANCE = 300;            // cm
const int MIN_DISTANCE = 15;              // cm
const float ANGLE_THRESHOLD = 80.0;      // Abschaltwinkel
const unsigned long MEASURE_INTERVAL = 60; // ms

// -------------------- Zustände --------------------
bool systemActive = true;
volatile bool wakeUpFlag = false;
unsigned long lastMeasureTime = 0;

// -------------------- Interrupt Service Routine --------------------
void wakeUpISR() {
  wakeUpFlag = true;
}

// -------------------- Setup --------------------
void setup() {

  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
  pinMode(BUZZER_PIN, OUTPUT);
  pinMode(BUTTON_PIN, INPUT_PULLUP);

  digitalWrite(TRIG_PIN, LOW);
  digitalWrite(BUZZER_PIN, LOW);

  Wire.begin();

  // MPU-6050 aufwecken (Sleep-Register deaktivieren)
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x6B);
  Wire.write(0);
  Wire.endTransmission();

  attachInterrupt(digitalPinToInterrupt(BUTTON_PIN), wakeUpISR, FALLING);

  Serial.begin(9600);
}

// -------------------- Hauptschleife --------------------
void loop() {

  // Taster ausgelöst?
  if (wakeUpFlag) {
    wakeUpFlag = false;

    bool previousState = systemActive;
    systemActive = !systemActive;

    delay(200);  // Entprellung

    if (!previousState && systemActive) {
      startupBeep();
    }
  }

  // Wenn ausgeschaltet -> Sleep
  if (!systemActive) {
    enterSleep();
    return;
  }

  // Zyklische Messung
  if (millis() - lastMeasureTime >= MEASURE_INTERVAL) {

    lastMeasureTime = millis();

    float angle = calculateTiltAngle();

    if (angle > ANGLE_THRESHOLD) {
      digitalWrite(BUZZER_PIN, LOW);
      return;
    }

    float distance = measureDistance();

    if (distance >= MIN_DISTANCE && distance <= MAX_DISTANCE) {
      handleBuzzer(distance);
    } else {
      digitalWrite(BUZZER_PIN, LOW);
    }
  }
}

// -------------------- Sleep-Modus --------------------
void enterSleep() {

  digitalWrite(BUZZER_PIN, LOW);

  set_sleep_mode(SLEEP_MODE_PWR_DOWN);
  sleep_enable();
  sleep_cpu();      
  sleep_disable();
}

// -------------------- Einschaltton --------------------
void startupBeep() {
  digitalWrite(BUZZER_PIN, HIGH);
  delay(150);
  digitalWrite(BUZZER_PIN, LOW);
}

// -------------------- Ultraschallmessung --------------------
float measureDistance() {

  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);

  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);

  long duration = pulseIn(ECHO_PIN, HIGH, 25000); // Timeout 25ms

  if (duration == 0) return -1;

  return (duration * SOUND_SPEED) / 2.0;
}

// -------------------- Neigungsberechnung --------------------
float calculateTiltAngle() {

  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x3B);
  Wire.endTransmission(false);
  Wire.requestFrom(MPU_ADDR, 6, true);

  int16_t accX = Wire.read() << 8 | Wire.read();
  int16_t accY = Wire.read() << 8 | Wire.read();
  int16_t accZ = Wire.read() << 8 | Wire.read();

  float ax = accX / 16384.0;
  float ay = accY / 16384.0;
  float az = accZ / 16384.0;

  float angle = atan2(sqrt(ax * ax + ay * ay), az) * 180.0 / PI;

  return angle;
}

// -------------------- Buzzersteuerung --------------------
void handleBuzzer(float distance) {

  unsigned long interval;

  if (distance > 200) interval = 800;
  else if (distance > 100) interval = 400;
  else if (distance > 50) interval = 200;
  else interval = 0;

  if (interval == 0) {
    digitalWrite(BUZZER_PIN, HIGH);
  } else {
    static unsigned long lastBeep = 0;
    static bool state = false;

    if (millis() - lastBeep >= interval) {
      lastBeep = millis();
      state = !state;
      digitalWrite(BUZZER_PIN, state);
    }
  }
}
