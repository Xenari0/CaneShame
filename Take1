//############################################
// - HC-SR04 Abstandsprüfung
// - Lautstärkeregler mit EEPROM
// - Gyro (MPU6050) für Vorwärtsneigung
// - PWM-Buzzer
// - Non-blockierende Logik über millis()
// - Feedbackton bei Lautstärkeänderung
//############################################
#include <Wire.h>
#include <MPU6050.h>
#include <EEPROM.h>

MPU6050 gyro;

// Pins
const int trigPin = 9;
const int echoPin = 10;
const int buzzerPin = 3;
const int buttonUp = 6;
const int buttonDown = 7;

// Sensor-Zeiten
unsigned long previousMillis = 0;
const unsigned long sensorInterval = 100;

// Lautstärke
int volume;
const int maxVolume = 255;
const int minVolume = 0;

// Feedback-Ton bei Volume-Change
bool volumeToneActive = false;
unsigned long volumeFeedbackStart = 0;
const unsigned long volumeToneDuration = 100;

// Button-Debounce
const unsigned long debounceTime = 150;
unsigned long lastUpPress = 0;
unsigned long lastDownPress = 0;
bool lastUpState = HIGH;
bool lastDownState = HIGH;

// Entfernung und Pitch
long duration;
float distance;
float angleThreshold = 70.0; // Max Pitch-Winkel in Grad

void setup() {
  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);
  pinMode(buzzerPin, OUTPUT);
  pinMode(buttonUp, INPUT_PULLUP);
  pinMode(buttonDown, INPUT_PULLUP);

  Serial.begin(9600);
  Wire.begin();
  gyro.initialize();

  if (!gyro.testConnection()) {
    Serial.println("MPU6050 Verbindung fehlgeschlagen");
    while (1);
  }

  // EEPROM lesen
  volume = EEPROM.read(0);
  volume = constrain(volume, minVolume, maxVolume);
}

void loop() {
  handleButtons();

  unsigned long currentMillis = millis();

  // Lautstärke-Feedback-Ton Ablaufprüfung
  if (volumeToneActive && currentMillis - volumeFeedbackStart >= volumeToneDuration) {
    analogWrite(buzzerPin, 0);
    volumeToneActive = false;
  }

  // Nur wenn kein Feedback aktiv, Sensorlogik ausführen
  if (!volumeToneActive && currentMillis - previousMillis >= sensorInterval) {
    previousMillis = currentMillis;

    readDistance();
    float pitch = getPitch();

    if (distance <= 300 && abs(pitch) <= angleThreshold) {
      analogWrite(buzzerPin, volume);
    } else {
      analogWrite(buzzerPin, 0);
    }
  }
}

void handleButtons() {
  unsigned long now = millis();

  // Up
  bool upState = digitalRead(buttonUp);
  if (upState != lastUpState) {
    if (upState == LOW && (now - lastUpPress >= debounceTime)) {
      volume = min(volume + 5, maxVolume);
      EEPROM.update(0, volume);
      triggerVolumeTone();
      lastUpPress = now;
    }
    lastUpState = upState;
  }

  // Down
  bool downState = digitalRead(buttonDown);
  if (downState != lastDownState) {
    if (downState == LOW && (now - lastDownPress >= debounceTime)) {
      volume = max(volume - 5, minVolume);
      EEPROM.update(0, volume);
      triggerVolumeTone();
      lastDownPress = now;
    }
    lastDownState = downState;
  }
}

void triggerVolumeTone() {
  analogWrite(buzzerPin, volume);
  volumeToneActive = true;
  volumeFeedbackStart = millis();
}

void readDistance() {
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);

  duration = pulseIn(echoPin, HIGH);
  distance = duration * 0.034 / 2; // cm
}

float getPitch() {
  int16_t ax, ay, az;
  gyro.getAcceleration(&ax, &ay, &az);

  float accX = ax / 16384.0;
  float accY = ay / 16384.0;
  float accZ = az / 16384.0;

  float pitch = atan2(accX, sqrt(accY * accY + accZ * accZ)) * 180.0 / PI;
  return pitch;
}
